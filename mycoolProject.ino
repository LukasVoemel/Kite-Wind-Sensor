#include <BH1750.h> // for the light sensor
#include <BMP180I2C.h> // for the Atmosphere BMP180 Sensor 
#include <DHT11.h> // DHT11 library to interface with the sensor
#include <Wire.h>  // allow communication with I2C devices 
// Light Sensor BH1750 
// PINS : 3.3V, GND, SCL(Serial Clock Line): D5 , SDA(Serial Data Line): D18 

#include <Adafruit_GFX.h>  // lib to controll the screen 
#include <Adafruit_SSD1306.h> //1306 is the display on the module. it is 0.96" 


#include <WiFi.h> //to connect to WiFi network
#include <HTTPClient.h> //for the GET request from OpenWeatherAPI
#include <ArduinoJson.h>

// pin vars for light sensor
#define SDA_PIN 18 
#define SCL_PIN 5

// define variabels for screen
#define SCREEN_WIDTH 128
#define SCREEN_HEIGTH 64
#define OLED_RESET -1 // not using the reset pin 

// Pin vars for the OLED display (Use different pins for the OLED display)
#define SDA_PIN_OLED 21
#define SCL_PIN_OLED 22

//define button and light pins 
#define BUTTON_PIN 23
#define LED_PIN 19  // this is the pin for the button light 
#define LED_PIN_RED 2// kite pin red 
#define LED_PIN_BLUE 4 // kite pin blue



#define DEBOUNCE_DELAY 200  // 200 milliseconds debounce delay


//create display object 
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGTH, &Wire1, OLED_RESET); 
BH1750 lightMeter(0x23);
BMP180I2C bmp180(0x77); // this should be the address for the pressure sensor
DHT11 dht11(15); //for ESP32: connect the sensor to pin GPIO2 (however on board it is pin15)

int buttonState = 0; 
int buttonCounter = 0;


//Wifi credentials
const char* ssid = "Network Name";  // use your own
const char* password = "Password";  // use your own

String URL = "openweathermap.org api key"; 

unsigned long currentMillis = 0;
unsigned long lastAPICallTime = 0;  // Time of last API call
unsigned long apiInterval = 180000; // 30 min in milliseconds
float windSpeed = -1;  // Wind speed, initial value -1 means not fetched


float initWindSpeed = 0; // this is to display the windspeed at bootup; 



// 'holgaaa', 128x64px
const unsigned char bitmap [] PROGMEM = {
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf0, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf8, 0x3f, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x0e, 0x1c, 0x07, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xc7, 0x0e, 0x01, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x71, 0xc3, 0xff, 0x00, 0x7f, 0xff, 0xff, 
0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfc, 0x78, 0xe1, 0xe7, 0x00, 0x1f, 0xff, 0xff, 
0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x3b, 0xf1, 0xe3, 0x80, 0x07, 0xff, 0xff, 
0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x03, 0x80, 0x1f, 0xb8, 0xe1, 0xc0, 0x1f, 0xff, 0xff, 
0xff, 0xfe, 0x00, 0x00, 0x00, 0x03, 0x1f, 0x01, 0xcf, 0x8e, 0x1c, 0x70, 0x01, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xc0, 0x00, 0x00, 0x3f, 0xcf, 0x81, 0xe3, 0x87, 0x1c, 0x20, 0x0f, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xf8, 0x00, 0x0c, 0x3c, 0xe7, 0xc0, 0xe1, 0xc7, 0x8c, 0x00, 0x3f, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xfe, 0x01, 0x1e, 0x3c, 0xf3, 0xe0, 0x71, 0xe3, 0x80, 0x00, 0x7f, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0x83, 0x8f, 0x1e, 0x79, 0xe0, 0x3f, 0xc0, 0x00, 0x01, 0xff, 0xff, 0xef, 0xff, 
0xff, 0xff, 0xff, 0xc1, 0xc7, 0x0e, 0x3d, 0xff, 0xce, 0x00, 0x00, 0x03, 0xff, 0xff, 0xc7, 0xff, 
0xff, 0xff, 0xff, 0xf1, 0xef, 0x87, 0x1c, 0xff, 0xc0, 0x00, 0x00, 0x07, 0xff, 0xff, 0x03, 0xff, 
0xff, 0xff, 0xff, 0xfc, 0xff, 0xc7, 0xbe, 0x7c, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xfe, 0x01, 0xff, 
0xff, 0xff, 0xff, 0xfe, 0x78, 0xe3, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xf8, 0x01, 0xff, 
0xf9, 0xff, 0xff, 0xff, 0x38, 0xf0, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xf0, 0x00, 0xff, 
0xf8, 0x3f, 0xff, 0xff, 0xfc, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xc0, 0x00, 0x7f, 
0xf0, 0x07, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x80, 0x00, 0x7f, 
0xf0, 0x01, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xfe, 0x00, 0x00, 0x7f, 
0xf0, 0x00, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xf8, 0x00, 0x00, 0x3f, 
0xf0, 0x00, 0x3f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xf0, 0x00, 0x00, 0x3f, 
0xf0, 0x00, 0x0f, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xc0, 0x00, 0x00, 0x3f, 
0xf0, 0x00, 0x03, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0x00, 0x00, 0x00, 0x3f, 
0xf0, 0x00, 0x00, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xf8, 0x00, 0x00, 0x00, 0x3f, 
0xf0, 0x00, 0x00, 0x3f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x01, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x3f, 
0xf0, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x07, 0xff, 0x00, 0x00, 0x00, 0x00, 0x3f, 
0xf0, 0x00, 0x00, 0x01, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x3f, 
0xf0, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0x00, 0x00, 0x7f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x3f, 
0xf0, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xf8, 0x07, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 
0xf8, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x7f, 
0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0xff, 
0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 
0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 
0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 
0xff, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 
0xff, 0x80, 0x00, 0x00, 0x00, 0x07, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 
0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 
0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 
0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 
0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 
0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 
0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 
0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 
0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 
0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};






void setup() {
  //-------------------------------BH1750 LightSensor-----------------

  Serial.begin(115200);  // establish a serial connection from esp32 to mac // can set baud rate if needed 

  Wire.begin(SDA_PIN, SCL_PIN); // is for the I2C communicatoin between I2C device and esp32

  if (lightMeter.begin(BH1750::CONTINUOUS_HIGH_RES_MODE)){
    Serial.println("BH1750 is good"); 
  }
  else{
    Serial.println("Error initializing BH1750"); 
  }

  //----------------------Atmosphere BMP180 Setup--------------------

  if(!bmp180.begin()){
    Serial.println("begin() failed. check BMP180 Interface and I2C address"); 
    while(1); 
  }

  //reset sensor to default parameters.
	bmp180.resetToDefaults();

	//enable ultra high resolution mode for pressure measurements
	bmp180.setSamplingMode(BMP180MI::MODE_UHR);

  //-------------------------SCREEN SETUP--------------------------


  Wire1.begin(SDA_PIN_OLED, SCL_PIN_OLED); // we need this since we have 2 I2C busses

  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)){
    Serial.print("Unable to init OLED"); 
    while(1); 
  }


  // Clear the buffer.
  display.clearDisplay();
  // Display bitmap
  display.drawBitmap(0, 0,  bitmap, 128, 64, WHITE);
  display.display(); 
  delay(2000); 


  //--------------------BUTTON/LED SETUP----------------------------

  pinMode(BUTTON_PIN, INPUT); // init button pin as input
  pinMode(LED_PIN, OUTPUT); //init led pin as output 
  pinMode(LED_PIN_RED, OUTPUT); // red part of the pin
  pinMode(LED_PIN_BLUE, OUTPUT); 


  //-------------------wifi setup------------------------------------
  WiFi.begin(ssid, password); 
  Serial.println("\nConnecting"); 


  int yPos = 0; 
  int xPos = 0; 
  while(WiFi.status() != WL_CONNECTED){
    Serial.print(".");
      delay(5000);
    display.setTextColor(SSD1306_WHITE);
    display.setCursor(xPos,yPos); 
    display.setTextSize(1);
    display.clearDisplay();
    display.print("Connecting to Network..");
    display.display();
    delay(100); 

    yPos = yPos + 10;
    xPos = xPos + 10;  
    

    if(yPos >= 30){
      yPos = 0;
      xPos = 0; 
    } 
  }
  Serial.println("\nConnected to the WiFi network");
  Serial.print("Local ESP32 IP: ");
  Serial.println(WiFi.localIP());


  initWindSpeed = fetchWindSpeed();
}

// Function to display data inside a box with centered text
void displayData(String title, float value, String unit) {
  display.clearDisplay();

  // Set the title of the data (centered in the screen)
  display.setTextColor(SSD1306_WHITE);
  display.setTextSize(1);
  display.setCursor((SCREEN_WIDTH - title.length() * 6) / 2, 5); // Center the title
  display.print(title);

  // Display the value (centered on the screen)
  display.setTextSize(2);  // Increase size for value display
  display.setCursor((SCREEN_WIDTH - String(value).length() * 6) / 2, 25); // Center the value
  display.print(value);

  // Display the unit (centered below the value)
  display.setTextSize(1);
  display.setCursor((SCREEN_WIDTH - unit.length() * 6) / 2, 45);  // Adjust cursor based on unit length
  display.print(unit);

  display.display();  // Render the updated content on the display
}

float fetchWindSpeed() {
  if (WiFi.status() == WL_CONNECTED) {
    HTTPClient http;
    bool windFetched = false; // Flag to check if wind speed is successfully fetched

    while (!windFetched) {  // Keep trying until wind speed is fetched
      http.begin(URL);  // set http request to URL
      int httpCode = http.GET(); // Start connection and send HTTP request

      Serial.print("HTTPCODE: ");
      Serial.println(httpCode);

      display.setTextColor(SSD1306_WHITE);
      display.setTextSize(1);
      display.clearDisplay();
      display.setCursor(10, 10);
      display.print("Getting wind speed" );
      display.display();

      if (httpCode > 0) {
        String JSON_Data = http.getString();
        Serial.println(JSON_Data);

        // Create a JSON document to store the parsed data
        StaticJsonDocument<1024> doc;

        // Deserialize the JSON response
        DeserializationError error = deserializeJson(doc, JSON_Data);

        // Extract wind speed if JSON parsing is successful
        if (!error) {
          windSpeed = doc["wind"]["speed"];
          if (windSpeed > 0) {
            windFetched = true;  // Successfully fetched wind speed
            Serial.print("Wind Speed: ");
            Serial.println(windSpeed);
          } else {
            Serial.println("Wind speed is 0 or unavailable, retrying...");
            delay(5000);  // Retry after 5 seconds if wind speed is invalid or unavailable
          }
        } else {
          Serial.println("Failed to parse JSON, retrying...");
          delay(5000);  // Retry after 5 seconds if parsing fails
        }
      } else {
        Serial.println("Failed to connect to API, retrying...");
        delay(1000);  // Retry after 5 seconds if HTTP request fails
      }

      http.end();  // End the HTTP request and free resources
    }
  } else {
    Serial.println("WiFi not connected");
    delay(5000);  // Retry every 5 seconds if Wi-Fi is not connected
  }

  return windSpeed; 
}

void loop() {

  if(WiFi.status() != WL_CONNECTED){
    Serial.println("Wifi lost, reconnecting..."); 
    WiFi.disconnect(); 
    WiFi.reconnect();
    delay(2000); 
  }
  
  //--------------------------gets all the data from the sensors---------------------
  float lux = lightMeter.readLightLevel();
  float pa = bmp180.getPressure();
  float mb = pa / 100; 
  float temp = bmp180.getTemperature(); 
  float humidity = dht11.readHumidity(); 
  float windMph = initWindSpeed * 2.23695;

  //------------------------sets all the display settings--------------------------
      
  display.clearDisplay();
  display.setCursor(0, 0);  // This places the text whereever you please 
  display.setTextColor(SSD1306_WHITE); // White text
  display.setTextSize(1);    // Use normal text size
 

  
  buttonState = digitalRead(BUTTON_PIN); 
  // Serial.println(buttonState); 
  // Serial.print("BUTTONCOUNTER: "); 
  // Serial.println(buttonCounter); 


  //--------------------------button press counter-------------------------------------
  if(buttonState == LOW){ // so here we could increase the counter
    //turn LED on
    delay(DEBOUNCE_DELAY); 
    digitalWrite(LED_PIN, HIGH); 
    buttonCounter++; //we need this here to track button presses
  }
  else{ // if button state is high which it alwasy is 
    //turn LED off
    digitalWrite(LED_PIN, LOW); 
  }

  //------------------------------RGB LED Logic----------------------------------------
  
  if(windMph > 11 && windMph < 25){
    analogWrite(LED_PIN_RED, 255);
    analogWrite(LED_PIN_BLUE, 0);
    delay(500); 

    analogWrite(LED_PIN_BLUE, 255);
    analogWrite(LED_PIN_RED, 0);
    delay(500); 
  }
  


  //------------------------switch for the button presses-------------------------------

  if (buttonCounter == 0) {
    displayData("Lux", lux, "lux");
  } else if (buttonCounter == 1) {
    displayData("Pressure", mb, "mb"); // millibar
  } else if (buttonCounter == 2) {
    displayData("Temp", temp, "degC");
  } else if (buttonCounter == 3) {
    displayData("Humidity", humidity, "%");
  } else if (buttonCounter == 4) {
    display.clearDisplay();
    // Display bitmap
    display.drawBitmap(0, 0,  bitmap, 128, 64, WHITE);
    display.display(); 
  } else if(buttonCounter == 5){
    displayData("WindSpeed", windMph,"mph" ); // optimal wind speed  for kite says about 8 - 18 mph 
  } else if(buttonCounter == 6){
    buttonCounter = 0; 
  }


  if (!bmp180.measureTemperature())
	{
		Serial.println("could not start temperature measurement, is a measurement already running?");
		return;
	}

	//wait for the measurement to finish. proceed as soon as hasValue() returned true. 
	do
	{
		delay(100);
	} while (!bmp180.hasValue());

	//start a pressure measurement. pressure measurements depend on temperature measurement, you should only start a pressure 
	//measurement immediately after a temperature measurement. 
	if (!bmp180.measurePressure())
	{
		Serial.println("could not start perssure measurement, is a measurement already running?");
		return;
	}

	//wait for the measurement to finish. proceed as soon as hasValue() returned true. 
	do
	{
		delay(100);
	} while (!bmp180.hasValue());


//------------------ Handle API Call Periodically ------------------

  currentMillis = millis();

  // so example start up should be  currentMillies (0) - lastAPICallTime(0) >= 360000 ---------FALSE so no good
  // 
  Serial.print("currentMillis: "); 
  Serial.println(currentMillis); 

  Serial.print("lastAPICallTime: "); 
  Serial.println(lastAPICallTime); 

  // If it's time to make the API call (every hour)
  if (currentMillis - lastAPICallTime >= apiInterval) {
    Serial.print("HEREHERHEHE"); 
    lastAPICallTime = currentMillis;  // Save the current timef

    initWindSpeed = fetchWindSpeed(); // Fetch the wind speed
  }

  Serial.print("WIFI: "); 
  Serial.println(WiFi.RSSI()); 

  Serial.print("Wi-Fi Status: ");
  Serial.println(WiFi.status());  // Print Wi-Fi status

  Serial.print("HEAPMEM: "); 
  Serial.println(ESP.getFreeHeap()); // dynamically allocated at runtime like string or http requsts etc 


}


